<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<title>Javascript Design Patterns</title>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
<link rel="stylesheet" href="/css/article.css">
</head>
<body>
	<nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">oskmkr</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

	
	<div class="container" id="content">

<p class="toc" style="undefined"></p><h2 id="javascript-essentials"><a name="javascript-essentials" href="#javascript-essentials"></a>javascript essentials</h2>
<h3 id="1.-javascript"><a name="1.-javascript" href="#1.-javascript"></a>1. Javascript</h3>
<ul>
<li>웹언어로 웹페이지의 일부 엘리먼트를 조작하기 위해 시작되었다.<br>현재 엄청난 발전이 이루어져 client-side 뿐 아니라 Server-side 코드를 작성할 수도 있다.<br>그 외 그 사용처는 무궁무진하다.</li>
<li>독특한 언어</li>
<li>클래스가 없으며, 함수(function)는 [일급 객체(first-class object)][1] 로 다양한 작업에 사용된다.<ol>
<li>변수나 데이터 구조 안에 담을 수 있다.</li>
<li>인자로 전달할 수 있다.</li>
<li>반환 값(return value)으로 사용할 수 있다.</li>
<li>런타임에 생성할 수 있다.</li>
<li>할당에 사용된 이름과 관계없이 고유하게 식별할 수 있다.</li>
</ol>
</li>
</ul>
<hr class="section">
<p>[1] : <strong class="highlight"> 일급객체(first-class object) </strong></p>
<ul>
<li>변수에 저장할 수 있다.</li>
<li>함수의 입력 파라메터로 사용할 수 있다.</li>
<li>함수의 출력 파라메터로 사용할 수 있다.</li>
<li>자료구조에 저장 가능해야한다.</li>
</ul>
<p>◎ 컴퓨터 과학자 Christopher Strachey가 만든 조어<br>◎ 함수가 런타임에도 생성되며, 함수의 인자로 전달되고 함수의 결과로서 리턴되며, 변수에 할당되는 것<br>◎ 함수도 데이터처럼 구성가능해짐(Composability)<br>◎ 일급함수라 함은 프로그램 언어에서 함수를 1급(first-class)의 지위로 사용하는가의 의미, JAVA, C<em class="underline"> 등의 OOP 언어에서는 클래스가 일급(first-class)의 지위를 갖는다. 대체적으로 함수를 일급의 지위로 사용하는 언어를 함수형 언어라고 한다.<br>◎ 함수형 언어 : Haskell, Erlang, ML, CommonLisp, Scheme, Clean, Clojure, Scala(최근 발표한 트위터에서 하루 2.5억의 타임라인을 저장, 분산 관리하는 프레임워크인 Gizzard 개발에 사용됨), Mathmatica, XSLT 그리고 javascript의 closures<br>◎ C</em>도 C++11에서 Lambda expression과 closures를 도입한다고 한다. 자바는 8버전에서 클로저를 도입하려 하였으나 최근에 폐기되었다고 한다.</p>
<hr class="section">
<p>java 와 비슷한 형태로 사용할 수 있으나, javascript 만의 독특한 특성을 받아들이고 사용하는 것이 더 좋다.</p>
<h3 id="2.-patterns"><a name="2.-patterns" href="#2.-patterns"></a>2. Patterns</h3>
<p>모범적 관행, 쓰임새에 맞게 추상화된 원리, 어떤 문제를 해결하기 위한 템플릿 </p>
<h3 id="3.-javascript-개념"><a name="3.-javascript-개념" href="#3.-javascript-개념"></a>3. Javascript 개념</h3>
<p>a. 객체지향 언어</p>
<p>객체란? 이름을 가진 프로퍼티를 가진 실체<br>키-값 쌍</p>
<p>JSON (JavaScript Object Notation)</p>
<pre><code class="JSON">{ key : value }
{ }
</code></pre>
<p>객체의 프로퍼티가 함수(객체) 라면 메소드라 부른다.<br>함수 또한 객체다. 프로퍼티와 메서드를 가질 수 있다.</p>
<p>b. 클래스가 없다</p>
<p>Java 객체를 만드는 과정</p>
<ol>
<li>클래스(명세)를 선언</li>
<li>클래스를 바탕으로 객체를 생성</li>
</ol>
<pre><code class="javascript">Foo foo = new Foo();
</code></pre>
<p>Javascript 에서 객체를 만드는 과정</p>
<ol>
<li>빈 객체를 필요한 시점에 생성</li>
<li>필요한 시점에 필요한 멤버를 추가하여 사용한다.</li>
</ol>
<pre><code class="javascript">foo = {};
</code></pre>
<h3 id="prototype"><a name="prototype" href="#prototype"></a>prototype</h3>
<p>Javascript 에서 상속을 구현하는 하나의 방법<br>prototype 또한 객체이며, 모든 함수는 prototype 프로퍼티를 갖는다.</p>
<h3 id="그-외"><a name="그-외" href="#그-외"></a>그 외</h3>
<ol>
<li><p>ECMAScript<br>core javascript 프로그래밍 언어는 ECMAScript 표준에 기반을 두고 있다.</p>
</li>
<li><p>JSLint<br>정적 분석 도구</p>
</li>
<li><p>console 객체<br>javascipt에 포함되어 있지 않으나, 대부분의 브라우저에서 지원하는 객체로,<br>alert() 과 달리 페이지 동작에 간섭을 주지 않고, 더 많은 정보를 쉽게 표현할  수  있다.</p>
</li>
</ol>
<h1 id="javascript-syntax"><a name="javascript-syntax" href="#javascript-syntax"></a>Javascript syntax</h1>
<h2 id="변수-선언"><a name="변수-선언" href="#변수-선언"></a>변수 선언</h2>
<pre><code class="javascript">var i = 0;
</code></pre>
<pre><code class="javascript">i = 0; // 전역 공간에 선언, anti-pattern
</code></pre>
<h2 id="주석"><a name="주석" href="#주석"></a>주석</h2>
<pre><code class="javascript">// 한줄 주석
/* 
여러 줄 주석
*/
</code></pre>
<h2 id="data-type"><a name="data-type" href="#data-type"></a>data type</h2>
<table>
<thead>
<tr>
<th>type</th>
<th></th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>문자열</td>
<td>“” 혹은 ‘’ 를 이용하여 사용, ‘’ 를 추천한다.</td>
</tr>
<tr>
<td>Number</td>
<td>숫자</td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>객체</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>불린</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<h2 id="special-charaters"><a name="special-charaters" href="#special-charaters"></a>special charaters</h2>
<table>
<thead>
<tr>
<th>character</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>new line</td>
</tr>
<tr>
<td>\b</td>
<td>backspace</td>
</tr>
<tr>
<td>\f</td>
<td>formfeed</td>
</tr>
<tr>
<td>\r</td>
<td>carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>tab</td>
</tr>
<tr>
<td>\</td>
<td>escape character</td>
</tr>
</tbody>
</table>
<h2 id="coding-standard"><a name="coding-standard" href="#coding-standard"></a>coding standard</h2>
<table>
<thead>
<tr>
<th>type</th>
<th>description</th>
<th>prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>문자열</td>
<td><code>var sName = &#39;oskm&#39;</code></td>
</tr>
<tr>
<td>Number</td>
<td>숫자</td>
<td><code>var nAge = 10</code></td>
</tr>
<tr>
<td>Object</td>
<td>객체</td>
<td><code>var oClass = {}</code></td>
</tr>
<tr>
<td>Array</td>
<td>배열</td>
<td><code>var aList = []</code></td>
</tr>
</tbody>
</table>
<h2 id="연산자(operators)"><a name="연산자(operators)" href="#연산자(operators)"></a>연산자(Operators)</h2>
<ol>
<li>지정 연산자 : = , -=, +=, *=, /=</li>
<li>비트(Bitwise)연산자 : &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=, &amp;=, ^=, |=</li>
<li>수치 연산자 : +, - ,*, /, %, ++, —</li>
<li>논리 연산자 : ||, &amp;&amp;, !</li>
<li>비트 논리 연산자 : |, &amp;, ^</li>
<li>비교 연산자 : ==, !=, &lt;=, &gt;=, &lt;, &gt;</li>
<li>스트링 연산자 : +, +=</li>
<li>오브젝트 생성 연산자 : new</li>
</ol>
<h2 id="조건문"><a name="조건문" href="#조건문"></a>조건문</h2>
<pre><code class="javascript">
if([condition]) {

} else if([condition]) {

} else {

}
</code></pre>
<h2 id="반복문"><a name="반복문" href="#반복문"></a>반복문</h2>
<pre><code class="javascript">while([condition]) {
    // do something...
}

do {
    // do something...
} while([condition]);

for([executed before loop starts];[condition];[executed each time after the loop]) {
    // do something...
}
</code></pre>
<h2 id="함수"><a name="함수" href="#함수"></a>함수</h2>
<pre><code class="javascript">
function [function_name]([arguments]) {
    // do something...
}
</code></pre>
<h1 id="base-pattern"><a name="base-pattern" href="#base-pattern"></a>base pattern</h1>
<p>고급 javascript 프로그래밍을 위한 유용한 기본 패턴을 알아본다. </p>
<h2 id="1.-전역-변수-최소화"><a name="1.-전역-변수-최소화" href="#1.-전역-변수-최소화"></a>1. 전역 변수 최소화</h2>
<p>전역 변수 선언 시 global 객체에 이 값이 생성된다. (브라우저에서는 window) </p>
<p>전역 변수는 모든 코드 내에서 공유된다. 목적이 다른 전역 변수를 같은 이름으로 사용하게 될 경우 문제가 발생할 수 있다.</p>
<p>여러 스크립트들 간의 충돌을 막으려면 최소화 하여야 한다.</p>
<p>특정 실행 context 內가 아니라면, this 는 이 global 객체를 가리킨다.</p>
<p>변수 선언 시 항상 var 를 사용할 것</p>
<p>javascript 는 변수 선언 없이 사용할 수 있고, 이러한 사용은 전역객체 프로퍼티가 된다.<br>(암묵적 전역(implied globals)) - 안티 패턴</p>
<p>단일 var 패턴</p>
<p>‘함수 상단에 var 선언을 한번만 쓰는 패턴</p>
<p>함수에서 필요로하는 모든 지역 변수를 한군데서 찾을 수 있다.<br>변수를 선언 전에 사용할 때 발생하는 로직상 오류를 막아준다. - hoisting 방지<br>변수 선언 후 사용에 대한 상기로 전역 변수 최소화에 도움<br>코드량 감소</p>
<h2 id="2.-호이스팅(hoisting)"><a name="2.-호이스팅(hoisting)" href="#2.-호이스팅(hoisting)"></a>2. 호이스팅(hoisting)</h2>
<p>호이스팅(hoisting)</p>
<p>함수 내 어느 위치에서든 여러 var 선언을 사용할 수 있지만, 실제 모두 함수 상단에 변수가 선언된 것과 동일하게 동작한다.</p>
<pre><code class="javascript">myname = &quot;global&quot;;
(func() {
     console.log(myname); // &quot;undefined&quot;
     var myname = &quot;local&quot;;
     console.log(myname); // &quot;local&quot;
})();
</code></pre>
<p>실제 동작</p>
<pre><code class="javascript">myname = &quot;global&quot;;
(func() {
     var myname;
     console.log(myname); // &quot;undefined&quot;
     myname = &quot;local&quot;;
     console.log(myname); // &quot;local&quot;
})();
</code></pre>
<h2 id="3.-for-in-loop"><a name="3.-for-in-loop" href="#3.-for-in-loop"></a>3. for-in loop</h2>
<p>for-in loop</p>
<p>객체를 순회할 때 사용하라<br>순서가 정해져 있지 않기 때문에 배열에 사용하는 것은 바람직 하지 않다.</p>
<h2 id="4.-내장-객체-생성자-확장"><a name="4.-내장-객체-생성자-확장" href="#4.-내장-객체-생성자-확장"></a>4. 내장 객체 생성자 확장</h2>
<p>내장 객체 생성자 prototype은 확장하지 말자.</p>
<pre><code class="javascript">Object.prototype.myMethod = function() {
    // do something
}
</code></pre>
<p>javascript 내장 메소드의 일관성을 기대하기 어려워진다.</p>
<h2 id="5.-완전-항등-연산자"><a name="5.-완전-항등-연산자" href="#5.-완전-항등-연산자"></a>5. 완전 항등 연산자</h2>
<p>완전 항등 연산자를 사용하라</p>
<p>암묵적 타입 캐스팅을 피하고, 명시적 비교를 수행함으로 예측하지 못한 결과를 피할 수 있다.</p>
<p>=<strong class="highlight">, !</strong> 완전 항등 연산자 값과 타입을 모두 확인한다.</p>
<pre><code class="javascript">var nValue = 0;

console.log(nValue === false);  // false
console.log(nValue == false);    // true
</code></pre>
<h2 id="6.-eval-is-evil"><a name="6.-eval-is-evil" href="#6.-eval-is-evil"></a>6. eval is evil</h2>
<p>eval is evil</p>
<p>대게 eval() 없이 목표에 도달할 수 있는 더 나은 방법이 존재한다.<br>최근 jsonp 보안 이슈도 이 맥락이다.</p>
<h2 id="7.-parseint()"><a name="7.-parseint()" href="#7.-parseint()"></a>7. parseInt()</h2>
<p>parseInt 를 통한 숫자 변환에 정수 베이스를 지정하여 사용하자</p>
<p>일관성 있는 변환을 원한다면 항상 정수 베이스를 지정하여야 한다.</p>
<p>API spec</p>
<pre><code>parseInt(&quot;문자열&quot;, radix(정수베이스));
</code></pre><p>radix가 제공되지 않거나 수치 0이 제공되었으면, 그 정수 베이스를 알아내려는 시도를 한다. 첫 문자가 1~9 사이 수치이면 10진수로, 0X나 0x로 시작하였으면 16진수로 파싱(parse)하게 된다.0으로 시작되었으면 실제적으로 8진수가 아니더라도 8진수로 파싱한다. </p>
<h2 id="8.-습관"><a name="8.-습관" href="#8.-습관"></a>8. 습관</h2>
<p>명명 규칙을 준수하자</p>
<p>변수와 함수 이름을 일관된 방식으로 사용한다.<br><br>생성자를 대문자로 시작하기(Pascal case)<br>function MyConstructor () {</p>
<p>}<br>메소드(camel case) 사용<br>function myFunction() {<br>}</p>
<p>상수<br>모든 글자를 대문자로 사용한다.<br><em>private 규칙<br>private 프로퍼티나 메소드에 접두어로 </em>를 사용한다.</p>
<p>JSLint 실행 습관화<br>자동화 필요</p>
<p>실행되지 않는 코드<br>변수를 정의하기 전에 사용한 경우<br>불안전한 UTF문자<br>void, with, eval 을 사용한 경우<br>정규식 내에서 부적절하게 이스케이프한 문자</p>
<p>등을 찾아낸다.</p>
<h1 id="javascript-literal-과-생성자"><a name="javascript-literal-과-생성자" href="#javascript-literal-과-생성자"></a>Javascript literal 과 생성자</h1>
<h2 id="1.-객체-리터럴"><a name="1.-객체-리터럴" href="#1.-객체-리터럴"></a>1. 객체 리터럴</h2>
<pre><code class="javascript">{ }
</code></pre>
<p>객체? 이름-값(key-value) 해시 테이블<br>value 로 primitive type, 객체<br>, function 모두 들어갈 수 있으며, 특히 function 은?</p>
<ul>
<li>Code : <pre><code class="javascript">var oFoo = { };
</code></pre>
</li>
</ul>
<ol>
<li>생성자 함수로 객체 생성</li>
<li>내장 생성자 함수 사용 ( e.g. Object, Array )<pre><code class="javascript">var oFoo = new Object(); // 안티 패턴
</code></pre>
</li>
</ol>
<p>내장 생성자를 왜 사용하지 말아야 하는가.</p>
<p>Object() 내장 생성자는 파라메터로 값을 받을 수 있는데 파라메터 타입에 따라 다른 객체를 리턴한다.</p>
<pre><code class="javascript">var o = new Object();
console.log(o.constuctor === Object); // true

var o = new Object(1);
console.log(o.constuctor === Number); // true

var o = new Object(&quot;string&quot;);
console.log(o.constuctor === String); // true

var o = new Object(true);
console.log(o.constuctor === Boolena); // true
</code></pre>
<p>런타임에 실행되는 값이 파라메터로 전달 되었을 때, 얘기치 못한 결과를얻는다.<br>new Object() 를 사용해 객체를 생성하지 말라 - 안티패턴</p>
<h2 id="2.-함수-리터럴"><a name="2.-함수-리터럴" href="#2.-함수-리터럴"></a>2. 함수 리터럴</h2>
<ol>
<li>리터럴을 이용한 객체 생성 패턴</li>
<li><strong>function</strong></li>
<li>더 짧다.</li>
<li>클래스로 부터 생성해야 하는 것이 아님을 보여준다.</li>
</ol>
<p>생성자 함수를 이용한 객체 생성</p>
<p>함수 선언.</p>
<pre><code class="javascript">
var Foo = function(sName) {
      this.sName = sName
      this.do = function() {
             return &quot;I am &quot; + this.sName; 
      }
}

var oFoo = new Foo();
</code></pre>
<p>실제 동작</p>
<pre><code class="javascript">var Foo = function(sName) {

      var this;
      this = {};

      this.sName = sName
      this.do = function() {
             return &quot;I am &quot; + this.sName; 
      }

      return this;
}
</code></pre>
<p>생성자 함수를 new 를 이용해 호출하면, 항상 객체가 반환된다. (암묵적으로 this반환)</p>
<p>기본값은 this,<br>원하는 객체를 return 하도록 정의할 수 있다. 만약 객체가 아닌 값을 반환하도록 하면 this 를 반환</p>
<p>만약 new 를 사용하지 않고 호출한다면??<br>생성자 내부의 this 가 global 객체를(window) 가리키게 된다.<br>전역 객체에 불필요한 프로퍼티가 생성되면서 더럽혀지게된다.<br>예상하지 못한 런타임 에러를 발생 시킬 수 있다.</p>
<pre><code class="javascript">function Foo() {
    this.age = 1;
}
var foo = Foo(); // 실행 순간 global객체(window) 에 age 가 추가된다.
</code></pre>
<p>해결을 위한 패턴 – 스스로를 호출하는 생성자</p>
<pre><code class="javascript">function Foo(sName) {
     if(!(this instanceof Foo)) {
           return new Foo();
     }

     this.sName = sName;
}
</code></pre>
<pre><code class="javascript">
// ES 5 strict 모드에서는 동작하지 않음.
function Foo(sName) {
     if(!(this instanceof arguments.callee)) {
           return new arguments.callee();
     }

     this.sName = sName;
}
</code></pre>
<h2 id="3.-배열-리터럴"><a name="3.-배열-리터럴" href="#3.-배열-리터럴"></a>3. 배열 리터럴</h2>
<p>[] vs Array();</p>
<pre><code class="javascript">var aShape = [&quot;triangle&quot;, &quot;rect&quot;, &quot;circle&quot;];
var aShape = new Array(&quot;triangle&quot;, &quot;rect&quot;, &quot;circle&quot;);
</code></pre>
<p>리터럴 문법이 훨씬 직관적이다.</p>
<p>배열 생성자</p>
<pre><code class="javascript">var array = new Array(3);  // [ undefined, undefined, undefined ]
</code></pre>
<p>숫자 하나를 전달할 경우 배열의 첫번째 값이 아니라 길이가 된다. </p>
<p>배열 생성자</p>
<pre><code class="javascript">var array = new Array(3.14); // RangeError: invalid array length
</code></pre>
<p>부동소수점 값을 전달할 경우 에러 발생</p>
<p>동적으로 배열을 생성할 때 얘기치 못한 오류 발생 위험이 있다.</p>
<h2 id="4.-json"><a name="4.-json" href="#4.-json"></a>4. JSON</h2>
<p>JavaScript Object Notation</p>
<p>객체 리터럴과의 차이점 - 프로퍼티명을 “” 로 감싸야한다. 항상 그런것은 아니고, 프로퍼티명에 공백문자가 포함된 경우</p>
<p>eval is evil -&gt; eval 을 사용하지 마라.</p>
<p>Jindo1 =&gt; toJSON() Object 재정의 했다… 안티패턴..ㅜ.ㅜ</p>
<p>Jindo1 core 발췌</p>
<pre><code class="javascript">/** @id Object.toJSON */
/*
Object.prototype.toJSON = function() {
return JINDO.obj2json(this);
};
*/
/** @id Array.toJSON */
Array.prototype.toJSON = function() {
return JINDO.obj2json(this);
};
</code></pre>
<p>Jindo2 =&gt; $Json() 사용</p>
<p>각 프레임워크는 이러한 파싱 유틸을 기본 제공한다.</p>
<h2 id="5.-정규-표현식-리터럴"><a name="5.-정규-표현식-리터럴" href="#5.-정규-표현식-리터럴"></a>5. 정규 표현식 리터럴</h2>
<pre><code class="javascript">var regx = /\\/gm;
var regx = new RegExp(&quot;\\\\&quot;, &quot;gm&quot;);
</code></pre>
<ul>
<li>g : 전역매칭</li>
<li>m : 여러줄 매칭</li>
<li>i : 대소문자 구분없이 매칭</li>
</ul>
<h2 id="6.-에러-객체"><a name="6.-에러-객체" href="#6.-에러-객체"></a>6. 에러 객체</h2>
<p>Error() 등…<br>name, message 프로퍼티를 갖는다.<br>사용안1)</p>
<p>throw 는 어떤 객체든지 던질 수 있다.</p>
<pre><code class="javascript">try {
    throw {
          name : &quot;Error&quot;,
          message : &quot;stack overflow...&quot;,
          type : &quot;Oops&quot;,
          errorCallback : function errorHandler() {
                  // handle errors
          }
    }
} catch(e) {
    alert(e.message);
    e.errorCallback();
}
</code></pre>
<p>사용안2)</p>
<pre><code class="language">throw Error(&quot;stack overflow..&quot;);
</code></pre>
<p>new 를 굳이 사용하지 않아도 new 를 사용한 것과 같이 동작하므로, 조금 더 짧게…</p>
<h1 id="함수-i"><a name="함수-i" href="#함수-i"></a>함수 I</h1>
<p>Javascript 에서 가장 중요한 것은 함수를 완벽히 익히는 것이다. </p>
<p>javascript 는 중괄호 ({ })유효범위 가 없다!!<br>오로지 함수 유효범위만 존재한다.</p>
<p><strong> 1. 함수는 객체다.</strong><br><strong> 2. 함수는 지역 유효범위를 제공한다.</strong></p>
<h2 id="1.-function-생성자-함수-사용"><a name="1.-function-생성자-함수-사용" href="#1.-function-생성자-함수-사용"></a>1. Function 생성자 함수 사용</h2>
<pre><code class="javascript">// 안티 패턴
var add = new Function(&quot;a, b&quot;, &quot;return a+b&quot;);
</code></pre>
<p>이 코드로 알 수 있는것?</p>
<p>함수도 객체라는 것을 확인할 수 있다.</p>
<p>이 방식을 지양해야하는 이유</p>
<ol>
<li>코드가 문자열로 전달되어 평가됨.</li>
<li>이스케이프를 해주어야하는 난해함.</li>
<li>유효 범위 제공 불가</li>
</ol>
<p>그러나 동적으로 생성할 때는 필요할 수 있다.</p>
<p>그러나 그런 날이 올까??</p>
<h2 id="2.-유효-범위"><a name="2.-유효-범위" href="#2.-유효-범위"></a>2. 유효 범위</h2>
<p><strong>함수로 감싸 진 경우만</strong> 지역 변수가 된다.<br><strong>함수가 유효범위를 제공한다.</strong></p>
<h2 id="3.-함수-표현식과-함수-선언문"><a name="3.-함수-표현식과-함수-선언문" href="#3.-함수-표현식과-함수-선언문"></a>3. 함수 표현식과 함수 선언문</h2>
<p>함수 표현식(함수 리터럴)</p>
<pre><code class="javascript">// 기명 함수 표현식(named function expression)
var foo = function foo() {
}
</code></pre>
<p>-&gt; 함수 객체의 name 프로퍼티에 add 랄 값이 들어간다. 그 외는 무명 함수 표현식과 동일.<br>-&gt; 기명 함수 표현식을 다른 이름의 변수에 할당할 수 있으나, IE 에서는 잘 동작하지 않으므로 일치시키는 것이 좋다.</p>
<pre><code class="javascript">// 무명 함수 표현식(unnamed function expression) -&gt; 함수 표현식(function expression)
var foo = function() {
}
</code></pre>
<p>함수 선언문</p>
<pre><code class="javascript">function foo() {

}
</code></pre>
<p>함수 선언문과 함수 표현식의 차이<br>함수 선언문은 전역 공간이나, 함수 내부에서만 사용가능하다.</p>
<p>즉, 함수 선언문을 사용할 수 없는 경우 함수 표현식을 사용한다. 함수 객체를 매개 변수로 전달하거나, 객체 리터럴로 매개 변수를 정의 하는 경우는 선언문을 사용할 수 없다.</p>
<p>함수 표현식을 사용하자.<br>함수 선언문보다 함수 표현식을 사용하는 것이 다른 객체들과 마찬가지로 객체의 일종이라는 것이 눈에 보인다.</p>
<h2 id="4.-함수-name-프로퍼티"><a name="4.-함수-name-프로퍼티" href="#4.-함수-name-프로퍼티"></a>4. 함수 name 프로퍼티</h2>
<pre><code class="javascript">// 함수 선언문
function foo() {}
// 기명 함수 표현식
var foo = function foo() {};
// 무명 함수 표현식
var foou = function () {};

console.log(foo.name); // foo
console.log(foo.name); // foo
console.log(foo.name); // FF, webkit 에서는 빈문자열(&quot;&quot;), IE 는 undefined
</code></pre>
<h2 id="5.-함수-호이스팅(hoisting)"><a name="5.-함수-호이스팅(hoisting)" href="#5.-함수-호이스팅(hoisting)"></a>5. 함수 호이스팅(hoisting)</h2>
<pre><code class="javascript">function foo() {
    console.log(&#39;global foo()&#39;);
}
function bar() {
    console.log(&#39;global bar()&#39;);
}

(function() {
    console.log(typeof foo);     // function
    console.log(typeof bar);     // function
})();
</code></pre>
<pre><code class="javascript">function foo() {
    console.log(&#39;global foo()&#39;);
}

function bar() {
    console.log(&#39;global bar()&#39;);
}

(function() {
    console.log(typeof foo);     // function
    console.log(typeof bar);     // undefined

    // 함수 선언, 정의된 함수가 hoisting 된다.
    function foo() {
        console.log(&#39;local foo()&#39;);
    }
    // 함수 표현, 변수 bar 만 hoisting 된다.
    var bar = function() {
        console.log(&#39;local bar()&#39;);
    }
})();
</code></pre>
<pre><code class="javascript">function foo() {
    console.log(&#39;global foo()&#39;);
}

function bar() {
    console.log(&#39;global bar()&#39;);
}

(function() {
    function foo() {
        console.log(&#39;local foo()&#39;);
    }

    var bar;

    console.log(typeof foo);
    console.log(typeof bar);

    bar = function() {
        console.log(&#39;local bar()&#39;);
    }
})();
</code></pre>
<p>함수 선언문, 정의된 함수가 hoisting 된다<br>함수 표현식, 변수만 hoisting 된다.</p>
<h1 id="함수-ii"><a name="함수-ii" href="#함수-ii"></a>함수 II</h1>
<p>Javascript 에서 가장 중요한 것은 함수를 완벽히 익히는 것이다. </p>
<p>javascript 는 중괄호 ({ })유효범위 가 없다!!<br>오로지 함수 유효범위만 존재한다.</p>
<p><strong> 1. 함수는 객체다. </strong><br><strong> 2. 함수는 지역 유효범위를 제공한다.</strong></p>
<h2 id="1.-callback-패턴"><a name="1.-callback-패턴" href="#1.-callback-패턴"></a>1. Callback 패턴</h2>
<p>함수는 객체이므로 인자로 functon 을 전달할 수 있다.<br>API 작성 시 매우 유용하다.<br>함수 자신의 역할(핵심)에만 집중하고, 그 외의 처리에 대해서는 콜백 함수에 맞겨 자유롭게 동작할 수 있도록 한다.<br>범용성, 확장성 확보</p>
<p>사용 예)</p>
<pre><code class="javascript">$Ajax(
    // 생략
    {
    // 생략
        onLoad : function() {
        }
    }

$Fn(this._onEvent, this).attach(document.body, &quot;click&quot;);
</code></pre>
<p>특정 이벤트가 발생하면, 어떠한 행위를 수행하는, 대부분 클라이언트 개발은 event-driven 방식이다.<br>콜백 패턴으로 인해 이러한 event-driven 개발 방식에 적합하다.</p>
<pre><code class="javascript">var doSomething = function(fCallback) {
     // 뭔가 핵심적인 비지니스 로직
     if(typeof fCallback == &quot;function&quot;) {
          fCallback();
     }
}
</code></pre>
<p>유효범위 문제</p>
<pre><code class="javascript">var myapp = {};
myapp.name = &#39;myApp1.0&#39;;

myapp.postProcessing = function() {
    console.log(&#39;This is &#39; + this.name);
}

var doSomething = function(fCallback) {
    // 뭔가 핵심적인 비지니스 로직
    if(typeof fCallback == &quot;function&quot;) {
        fCallback();
    }
}
myapp.postProcessing(); // This is myApp1.0 
doSomething(myapp.postProcessing); // This is
</code></pre>
<p>개선</p>
<pre><code class="javascript">var myapp = {};
myapp.name = &#39;myApp1.0&#39;;

myapp.postProcessing = function() {
    console.log(&#39;This is &#39; + this.name);
}
var doSomething = function(fCallback, oContext) {
    // 뭔가 핵심적인 비지니스 로직
    if(typeof fCallback == &quot;function&quot;) {
        fCallback.call(oContext);
    }
}
myapp.postProcessing(); // This is myApp1.0 
doSomething(myapp.postProcessing, myapp); // This is myApp1.0
</code></pre>
<h2 id="2.-함수-반환"><a name="2.-함수-반환" href="#2.-함수-반환"></a>2. 함수 반환</h2>
<p>함수는 객체이므로 반환할 수 있다.</p>
<pre><code class="javascript">var counter = function() {
    var i = 0;
    return function() {
        console.log(&#39;count : &#39; + i++);
    }
}
var myCounter = counter();
myCounter(); // count : 0
myCounter(); // count : 1
myCounter(); // count : 2
</code></pre>
<p>클로저(Closure)</p>
<p>함수를 실행하는데 필요한 지역변수와 결합된 Function 인스턴스<br>콜백함수를 선언할 때 지역 변수를 유지하면서 참조할 수 있는 능력</p>
<p>함수가 선언되면, 해당 함수는 선언 시점에 범위안에 있는 변수를 참조할 수 있다. 함수가 참조할 수 있는 변수들은 선언한 후에 범위를 벗어나더라도 함수와 함께 수행된다.</p>
<pre><code class="javascript">(function() {
     var local = 1; // 1) 함수 내 변수
     window.setInterval(function() {
          console.log(&#39;local=&#39; + local);
          local++; // 내부 함수가 1) 을 참조
     }, 300);
})();
</code></pre>
<p>함수내의 변수를 내부함수가 참조하고 있기 때문에 유지되어 접근할수 있는 함수를 클로저라고 합니다.</p>
<p>콜백 함수가 실행되는 동안 local은 존재하지 않는다고 생각되어진다.<br>함수의 선언으로 생성된 클로저는 local을 포함한다. 즉 함수의 생명주기 동안 변수가 해제되지 않고 범위에 있도록 유지된다.</p>
<p>특별히 주의할 점<br>context 는 클로저의 일부로 포함되지 않는다.<br>각 함수 호출은 자신의 함수 context 를 소유한다는 점.</p>
<h2 id="3.-this의-모든-것"><a name="3.-this의-모든-것" href="#3.-this의-모든-것"></a>3. this의 모든 것</h2>
<p>클래스 중심의 객체지향 언어에서는 메서드가 선언된 클래스의 인스턴스를 this 포인터가 참조한다.</p>
<p>javascript에서는 함수가 어딘가에 속해서 선언되지 않는다. 함수의 선언이 아니라, 함수가 어떻게 호출되었는 지에 따라 결정된다.<br>동일한 함수라도 어떻게 호출되었느지에 따라 다른 콘텍스트를 가짐을 의미한다.</p>
<pre><code class="javascript">window.name = &#39;window&#39;;

function whoAmI() {
    console.log(this.name);
}

var itsMe = {
    name : &#39;itsMe&#39;
};

whoAmI(); // window
itsMe.whoAmI = whoAmI;
itsMe.whoAmI(); // itsMe
whoAmI.call(itsMe); // itsMe
whoAmI.apply(itsMe); // itsMe
</code></pre>
<p>실행 context 를 마음대로 지정할 수 있다.<br>call 은 추가 매개 변수로 , 구분자를 이용해 받고,<br>apply 는 추가 매개 변수로 객체의 배열을 받는다.</p>
<p>Jindo2 는 $Fn 에 bind 추가</p>
<pre><code class="javascript">jindo.$Fn.prototype.bind = function() {
    var a = jindo.$A(arguments).$value();
    var f = this._func;
    var t = this._this;
    var b = function() {
          var args = jindo.$A(arguments).$value();
          // fix opera concat bug
          if (a.length) args = a.concat(args);
          return f.apply(t, args);
    };
    return b;
};
</code></pre>
<p>jindo1 은 Function 에 bind 추가</p>
<pre><code class="javascript">bind : function(obj) {
    var f=this, a=$A(arguments);
    a.shift();
    return function() {
         return f.apply(obj, a);
    }
},
</code></pre>
<h2 id="4.-lazy-function-definition"><a name="4.-lazy-function-definition" href="#4.-lazy-function-definition"></a>4. Lazy function definition</h2>
<p>여러 번 호출될 수 있는 어떤 함수가 초기화 준비 작업을 단 한번만 수행할 때 유용하다.<br>재정의 하면서 수행부의 양이 줄어들기 때문에 어플리케이션 성능향상에 도움</p>
<pre><code class="javascript">var myapp = {};

myapp.name = &#39;MyApp&#39;;
myapp.running = function() {

    myapp.bStarted = true;
    console.log(&#39;ready...&#39;);

    this.running = function() {
        console.log(&#39;run...&#39;);
    }
}
myapp.running();
myapp.running();
myapp.running();
</code></pre>
<h2 id="5.-즉시-실행-함수"><a name="5.-즉시-실행-함수" href="#5.-즉시-실행-함수"></a>5. 즉시 실행 함수</h2>
<p>함수가 선언되자마자 실행되도록 하는 문법이다. (스크립트가 로딩됨과 함께 수행된다.)</p>
<p>함수를 함수 표현식으로 선언한다.<br>함수가 즉시 실행될 수 있도록 마지막에 괄호쌍을 추가한다.<br>전체 함수를 괄호로 감싼다.</p>
<ol>
<li>초기화 등 한번만 실행해야할 때</li>
<li>따라서 이름이 지정된 함수를 생성할 필요가 없을 때</li>
<li>초기화에만 사용할 지역 유효범위 변수를 사용할 때 </li>
</ol>
<p>사용한다.</p>
<pre><code class="javascript">(function() {
     // 구현부
})();
</code></pre>
<pre><code class="javascript">(function(global, when) {
     // 구현부
})(this, new Date());
</code></pre>
<p>와 같이 파라메터를 전달할 수도 있다.</p>
<p>즉시 실행함수는 전역 네임스페이스를 더럽히지 않고, Sandbox 를 제공하여 주기 때문에 모듈화에 유용하다.</p>
<p>즉 단위 테스트(점진적 개선 작업)에도 적합하다.</p>
<h2 id="6.-즉시-객체-초기화-패턴"><a name="6.-즉시-객체-초기화-패턴" href="#6.-즉시-객체-초기화-패턴"></a>6. 즉시 객체 초기화 패턴</h2>
<p>즉시 실행 함수와 동일한  장점을 제공한다.</p>
<pre><code class="javascript">({
// 설정 값 정의
    name : &#39;myApp&#39;,
    init : function() {
         //초기화작업
    }
}).init();
</code></pre>
<h1 id="상속"><a name="상속" href="#상속"></a>상속</h1>
<h2 id="1.-객체-지향-프로그래밍"><a name="1.-객체-지향-프로그래밍" href="#1.-객체-지향-프로그래밍"></a>1. 객체 지향 프로그래밍</h2>
<p>프로토 타입 기반 프로그래밍은<br>객체지향 프로그래밍의 한 형태입니다.</p>
<p>클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다.</p>
<p>프로토 타입기반 프로그래밍은 클래스리스(class-less), 프로토타입지향 혹은 인스턴스기반 프로그래밍이라고도 합니다.</p>
<ul>
<li>사내 javascript 개발 가이드 발췌
</li>
</ul>
<p>클래스 기반<br>클래스 사이의 분류와 관계에 초점</p>
<p>프로토타입 기반<br>동작 방식에 초점</p>
<h2 id="2.-클래스-모방"><a name="2.-클래스-모방" href="#2.-클래스-모방"></a>2. 클래스 모방</h2>
<p>대부분의 자바 스크립트 프레임웍들은 클래스를 흉내내어 비슷하게 작성할 수 있도록 하는 기법(function) 을 제공한다.</p>
<p>공통점</p>
<ol>
<li>클래스의 생성자에 해당하는 메소드의 몀명 규칙이 있으며, 자동으로 호출된다.</li>
<li>클래스는 다른 클래스로부터 상속될 수 있다.</li>
<li>자식 클래스 내부에서 부모 클래스에 접근할 수 있는 경로가 존재한다.</li>
</ol>
<p>Jindo1</p>
<ol>
<li>__init : function() {}</li>
<li>extend</li>
<li>없음.</li>
</ol>
<pre><code class="javascript">var Parent = Class({
    __init : function() {
        console.log(&#39;Parent()&#39;);
        this.name = &#39;Parent&#39;;
    },
    say : function() {
        console.log(this.name + &#39; saying&#39;);
    }
});
var Child = Class.extend(Parent, {
    __init : function() {
        console.log(&#39;Child()&#39;);
        this.name = &#39;Child&#39;;
    },
    say : function() { // method overriding
        console.log(this.name + &#39; saying &#39; + &#39;lalala~&#39;);
    }
});
var oC = new Child();
oC.say();
</code></pre>
<p>Jindo2</p>
<ol>
<li>$init : function() {}</li>
<li>extend</li>
<li>$super</li>
</ol>
<pre><code class="javascript">var Parent = $Class({
    $init : function() {
        console.log(&#39;Parent()&#39;);
        this.name = &#39;Parent&#39;;
    },
    say : function() {
        console.log(this.name + &#39; saying&#39;);
    }
});

var Child = $Class({
    $init : function() {
        console.log(&#39;Child()&#39;);
        this.name = &#39;Child&#39;;
    },
    say : function() {  // method overriding
        this.$super.say();
        console.log(this.name + &#39; saying &#39; + &#39;lalala~&#39;);
    }
}).extend(Parent);
var oC = new Child();
oC.say();
</code></pre>
<p>클래스 모방 패턴 구현은 피하는 것이 좋다.<br>언어에는 존재하지 않는 추가적인 개념과 규칙을 만들어내고,<br>또한 사용법을 기억하고 익혀야한다.<br>그러나, 프로토타입 개념이 낯설고, 클래스 개념에 익숙할 경우 유용할 수 있다.</p>
<p>ECMAScript 5 추가사항<br><br>Object.create() 가 이 클래스 모방 패턴을 구현하고 있다.<br><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create</a><br>API Specification<br>Object.create(proto [, propertiesObject ])
</p>
<pre><code class="javascript">function Parent() {
    this.name = &#39;Parent&#39;;
    this.age = 18;
    console.log(&#39;initialize Parent...&#39;);
}
function Child() {
    this.name = &#39;Child&#39;;
    console.log(&#39;initialize Child...&#39;);
}

Parent.prototype.getName = function() {
    return &#39;my name is &#39; + this.name;
};
Parent.prototype.getAge = function() {
    return &#39;I am &#39; + this.age + &#39; years old&#39;;
};
var oC = Object.create(Parent.prototype);
//var oC = Object.create(new Parent());
</code></pre>
<h2 id="3.-프로토타입을-활용한-상속"><a name="3.-프로토타입을-활용한-상속" href="#3.-프로토타입을-활용한-상속"></a>3. 프로토타입을 활용한 상속</h2>
<p>객체는 함수로부터 생성되고, 함수는 객체(or 프로토타입)를 프로토타입으로 가집니다.<br>o<br>객체에는 자신을 생성한 생성자를 가리키는 constructor 존재</p>
<p>prototype은 this.constructor.prototype 으로 확인 가능 (FF에서는 <strong>proto</strong> 로 더 간단히 접근 가능)</p>
<h4 id="additional"><a name="additional" href="#additional"></a>additional</h4>
<h5 id="1.-hasownproperty"><a name="1.-hasownproperty" href="#1.-hasownproperty"></a>1. hasOwnProperty</h5>
<p>result = object.hasOwnProperty(propertyName);</p>
<h5 id="2.-in-연산자"><a name="2.-in-연산자" href="#2.-in-연산자"></a>2. in 연산자</h5>
<p>result = propertyName in object</p>
<pre><code class="javascript">var Terminal = function() {
    this.name = &#39;Foo&#39;;
    this.ls = function() {
        console.log(&#39;ls&#39;);
    }
}

Terminal.prototype.tail = function() {
    console.log(&#39;tail&#39;);
}

var oTerminal = new Terminal();

oTerminal.hasOwnProperty(&#39;ls&#39;);                            // true
oTerminal.hasOwnProperty(&#39;tail&#39;);                        // false
oTerminal.constructor.prototype.hasOwnProperty(&#39;ls&#39;);    // false
oTerminal.constructor.prototype.hasOwnProperty(&#39;tail&#39;);    // true
&#39;ls&#39; in oTerminal    // true
&#39;tail&#39; in oTerminal    // true
</code></pre>

		
	</div>
	
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>	
</body>
</html>

